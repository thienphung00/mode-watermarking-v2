"""
Demo route for Phase-1 presentation.

⚠️ PHASE-1 DEMO ONLY ⚠️
This demo is presentation-only and does not reflect production performance.
Runs on CPU and exists solely to visualize the watermark lifecycle.
No pipeline or watermark logic is modified.
"""
from __future__ import annotations

import io
from pathlib import Path

from fastapi import APIRouter, UploadFile, File, Form, HTTPException
from fastapi.responses import HTMLResponse
from PIL import Image

from service.app.dependencies import get_detection_service, is_detection_available, get_detection_availability_status
from service.infra.logging import get_logger

logger = get_logger(__name__)

router = APIRouter()

# Path to demo.html
DEMO_HTML_PATH = Path(__file__).parent.parent / "static" / "demo.html"


@router.get("/demo", response_class=HTMLResponse)
async def demo():
    """
    Serve the Phase-1 demo page.
    
    This is a presentation-only demo for non-technical users (e.g., recruiters).
    It wraps the existing API endpoints without modifying any watermark logic.
    """
    try:
        with open(DEMO_HTML_PATH, "r", encoding="utf-8") as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except FileNotFoundError:
        return HTMLResponse(
            content="<h1>Demo not found</h1><p>demo.html is missing from service/app/static/</p>",
            status_code=404
        )


@router.post("/demo/verify")
async def demo_verify(
    image: UploadFile = File(...),
    key_id: str = Form(...),
):
    """
    Demo-friendly watermark verification endpoint.
    
    This endpoint accepts image file uploads via multipart/form-data and verifies
    whether the image contains a watermark generated by our service.
    
    This is a product/UI adapter endpoint that:
    - Accepts browser-style file uploads (multipart/form-data)
    - Requires key_id for DDIM inversion and g-value recomputation
    - Returns simplified, demo-safe responses
    - Internally reuses the existing DetectionService
    
    Args:
        image: Uploaded image file (multipart/form-data)
        key_id: Watermark key identifier (required for detection)
    
    Returns:
        Dictionary with:
            - verified: bool (whether watermark was detected)
            - confidence: float (detection confidence, 0-1)
            - score: float (detection score, log-odds)
            - watermark_version: str (watermark policy version)
    
    Raises:
        HTTPException: 400 if image cannot be processed or key_id is missing, 404 if watermark not found
    """
    try:
        # Validate key_id is provided and not empty
        if not key_id or not key_id.strip():
            raise HTTPException(
                status_code=400,
                detail="key_id is required for watermark detection. It is needed for DDIM inversion and g-value recomputation."
            )
        
        effective_key_id = key_id.strip()
        
        # Check if detection artifacts are available (demo mode)
        if not is_detection_available():
            availability_status = get_detection_availability_status()
            raise HTTPException(
                status_code=503,
                detail={
                    "error": "Detection artifacts not configured",
                    "hint": "Set LIKELIHOOD_PARAMS_PATH or mount outputs directory",
                    "mode": "demo",
                    "details": availability_status.get("error", "Unknown error"),
                }
            )
        
        # Read uploaded file contents
        contents = await image.read()
        
        # Convert to PIL Image
        img = Image.open(io.BytesIO(contents)).convert("RGB")
        
        logger.info(
            "demo_verify_started",
            extra={"key_id": effective_key_id}
        )
        
        # Get detection service (will raise if artifacts not available)
        try:
            detection_service = get_detection_service()
        except RuntimeError as e:
            # This should not happen if is_detection_available() passed, but handle gracefully
            raise HTTPException(
                status_code=503,
                detail={
                    "error": "Detection service unavailable",
                    "hint": "Detection artifacts are not configured",
                    "mode": "demo",
                    "details": str(e),
                }
            ) from e
        
        # Run detection
        result = detection_service.detect(
            image=img,
            key_id=effective_key_id,
        )
        
        logger.info(
            "demo_verify_completed",
            extra={
                "key_id": effective_key_id,
                "verified": result["detected"],
                "score": round(result["score"], 4),
                "confidence": round(result["confidence"], 4),
            }
        )
        
        # Return simplified, demo-safe response
        return {
            "verified": result["detected"],
            "confidence": result["confidence"],
            "score": result["score"],
            "watermark_version": result["watermark_version"],
        }
    
    except ValueError as e:
        error_msg = str(e)
        # Check if this is a watermark not found error (404) vs validation error (400)
        if "not found" in error_msg.lower() or "revoked" in error_msg.lower():
            raise HTTPException(status_code=404, detail=error_msg)
        else:
            raise HTTPException(status_code=400, detail=error_msg)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(
            "demo_verify_failed",
            extra={"error": str(e)},
            exc_info=True
        )
        raise HTTPException(status_code=400, detail=str(e))

